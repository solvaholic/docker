name: Docker

# Use this workflow to:
# - Manually build and push an image from a branch
# - Automatically build and push on certain pushes
# - Automatically test new/udpated deployments

on:
  push:
    # Run this workflow if */Dockerfile in main branch changed.
    branches:
      - main
    paths:
      - '*/Dockerfile'

  # Run when manually triggered
  workflow_dispatch:
    inputs:
      # User inputs the release version, for example `1.2.3`
      version:
        description: 'Release version to create, for example 1.2.3'
        required: true
        default: "2.1.3"

jobs:
  # Build and push any Dockerfile changed in this push.
  build-and-push:
    runs-on: ubuntu-latest

    outputs:
      fullref: ${{ steps.gettagver.outputs.fullref }}
      shortref: ${{ steps.gettagver.outputs.shortref }}
      sharef: ${{ steps.gettagver.outputs.sharef }}
      tagbuilt: ${{ steps.buildimage.outputs.tagbuilt }}
      tagpushed: ${{ steps.pushimage.outputs.tagpushed }}

    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ github.event.after }}
          fetch-depth: '25'

      - name: Get version details
        # TODO: Re-ID me
        id: gettagver
        run: |
          _full_ref="${{ github.ref }}"
          _short_ref=
          _sha_ref="${{ github.sha }}"     # TODO: Use only one?
          _sha_short="${{ github.sha }}"
          if [[ "${_full_ref}" == "refs/heads/"* ]]; then
            _short_ref=${_full_ref#refs/heads/}
          elif [[ "${_full_ref}" == "refs/tags/"* ]]; then
            _short_ref=${_full_ref#refs/tags/}
          else
            echo "FAIL: Did not recognize GITHUB_REF '${_full_ref}'."
            exit 1
          fi
          echo "Set fullref to '${_full_ref}'."
          echo "Set shortref to '${_short_ref}'."
          echo "Set sharef to '${_sha_ref}'."
          echo "::set-output name=fullref::${_full_ref}"
          echo "::set-output name=shortref::${_short_ref}"
          echo "::set-output name=sharef::${_sha_ref}"

      - name: List Dockerfiles to build
        # When a filename ending with /Dockerfile' has changed,
        # append it to a file named _files
        run: |
          git diff --name-only ${{ github.event.before }} \
          ${{ github.event.after }} | \
          sed -n -e "/\/Dockerfile$/p" > _files

      - name: Build image(s)
        # Get app name from parent dir, and build each Dockerfile:
        #   <repo-owner>/<app-name>:latest
        run: |
          _image_ver="${{ steps.gettagver.outputs.sharef }}"

          echo "::debug::_files is ..." && cat _files
          : > _images
          cat _files | while read -r _thisfile; do
            _appname="${_thisfile%%/*}" _filename="${_thisfile##*/}"
            echo "::debug::_thisfile, _appname are ..." && \
            echo "${_thisfile} ${_appname}"
            if [ -f "${_thisfile}" ]; then
              _tag=${{ github.repository_owner }}/"${_appname}":latest
              tar c -C "${_appname}" . | docker build -t "${_tag}" -
              echo "${_tag}" >> _images
            fi
          done



          if docker build . -q \
            --build-arg image_version="${_image_ver}" \
            -t "${_image_tag}"; then
            echo "Built '${_image_tag}' OK."
          else
            echo "FAIL: Failed to build '${_image_tag}'."
            exit 1
          fi



      - name: Push image(s) to ghcr.io
        run: |
          echo "${{ secrets.PAT }}" | \
          docker login ghcr.io \
          -u ${{ github.actor }} --password-stdin
          echo "::debug::_images is ..." && cat _images
          cat _images | while read -r _thisimage; do
            # For GitHub's registry, prepend ghcr.io
            _mytag="ghcr.io/${_thisimage}"
            docker tag "${_thisimage}" "${_mytag}"
            echo "::debug::Pushing ${_mytag}"
            docker push "${_mytag}"
          done

      - name: Push image(s) to Docker hub
        run: |
          echo "${{ secrets.dockerhub_token }}" | \
          docker login -u ${{ github.actor }} --password-stdin
          echo "::debug::_images is ..." && cat _images
          cat _images | while read -r _thisimage; do
            # For Docker hub, use only the owner and topic names.
            _mytag="${_thisimage%%/*}/${_thisimage##*/}"
            docker tag "${_thisimage}" "${_mytag}"
            echo "::debug::Pushing ${_mytag}"
            docker push "${_mytag}"
          done
